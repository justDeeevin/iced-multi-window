# `iced-multi-window`

Utilities for managing many windows in an `iced` application.

## Goals

Working with multiple windows in iced can become quite painful quite quickly. If you want to introduce a window type with unique behavior, you may have to make additions in more than five places accross your codebase. Oversights are easy, and most of the mistakes you can make aren't caught by the compiler. This library seeks to ease this experince by making defining and working with multiple windows simpler, more intuitive, and harder to screw up.

## Usage

The first step is to define the windows that will appear in your app. This is done by creating a corresponding struct and implementing the `Window` trait for it. This trait will describe the logic behind that window's content, title, and theme, as well as defining its spawn-time settings.

Once you have your windows defined, you have to declare them using the `multi_window` macro **at the top level of your crate** (`main.rs` or `lib.rs`)[^1]. This macro will generate an enum that allows for windows to be passed around polymorphically without the use of dynamic dispatch.

Finally, add a `WindowManager` to your app state. This keeps track of the
`Id`s and
corresponding identities of all of the windows in your app. It will also return the proper
view, title, and theme given an `Id`. Thus, instead of checking the `Id` in these functions, you just call the right method on the `WindowManager`.  
This has one caveat: you have to tell the `WindowManager` when a window is closed. This is done by calling the `closed` method with the `Id` of the window that was closed. The simplest way to do this is to add a message variant for a window closure, then use `iced::event::listen_with` to listen for window closures.

```rust
fn subscription(&self) -> iced::Subscription<Self::Message> {
    iced::event::listen_with(|event, _| {
        if let iced::Event::Window(id, iced::window::Event::Closed) = event {
            Some(Message::WindowClosed(id))
        } else {
            None
        }
    })
}

fn update(^mut self, message: Self::Message) -> iced::Command<Self::Message> {
    match message {
        ...
        Message::WindowClosed(id) => {
            self.windows.closed(id);
        }
    }
}
```

When using any function that expects a window (such as `WindowManager::spawn`), pass in the
`window!` macro. This is shorthand for the particular enum variant of the window you want to
use.

The name of the enum generated by the `multi_window` macro is `WindowUnion`, and can be
imported if needed.

[^1]: The `window!` macro assumes that the generated enum is in at the top level to avoid requiring
you to import it yourself.
